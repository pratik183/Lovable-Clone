package com.lovable.com.lovable.controller;

import com.lovable.com.lovable.dto.subscription.*;
import com.lovable.com.lovable.service.PaymentProcessor;
import com.lovable.com.lovable.service.PlanService;
import com.lovable.com.lovable.service.SubscriptionService;
import com.stripe.model.Event;
import com.stripe.model.EventDataObjectDeserializer;
import com.stripe.model.StripeObject;
import com.stripe.model.checkout.Session;
import com.stripe.net.Webhook;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequiredArgsConstructor
@Slf4j
public class BillingController {

    private final PlanService planService; // Exposes available plans
    private final SubscriptionService subscriptionService; // Manages user subscriptions and Stripe flows
    private final PaymentProcessor paymentProcessor;

    @Value("${stripe.webhook.secret}")
    private String stripeWebhookSecret; // Secret for verifying Stripe webhooks

    @GetMapping("/api/plans")
    public ResponseEntity<List<PlanResponse>> getAllPlans(){
        return ResponseEntity.ok(planService.getAllActivePlans()); // List active/marketed plans
    }

    @GetMapping("/api/me/subscription")
    public ResponseEntity<SubscriptionResponse> getMySubscription(){
        Long userId = 1L; // TODO: obtain from auth context
        return ResponseEntity.ok(subscriptionService.getCurrentSubscription(userId)); // Return current user's subscription info
    }

    @PostMapping("/api/payments/checkout")
    public ResponseEntity<CheckoutResponse> crateCheckoutResponse(
            @RequestBody CheckoutRequest request
            ){
        return ResponseEntity.ok(paymentProcessor.createCheckoutSessionUrl(request)); // Create Stripe checkout session URL
    }

    @PostMapping("/api/payments/portal")
    public ResponseEntity<PortalResponse> openCustomerPortal(){
        Long userId = 1L; // TODO: obtain from auth context
        return ResponseEntity.ok(paymentProcessor.openCustomerPortal(userId)); // Open Stripe customer portal for billing management
    }

    @PostMapping("/webhooks/payment")
    public ResponseEntity<String> handlePaymentWebhook(
            @RequestBody String payload,
            @RequestHeader("Stripe-Signature") String sigHeader
    ){
        try{
            Event event = Webhook.constructEvent(payload, sigHeader, stripeWebhookSecret);

            EventDataObjectDeserializer deserializer = event.getDataObjectDeserializer();
            StripeObject stripeObject = null;

            // Below all code taken from stripe docs to handle deserialization safely
            if(deserializer.getObject().isPresent()){ // happy case - if the event we are getting from stripe is the same as the sdk version then deserialize successfully
                stripeObject = deserializer.getObject().get();
            } else {
                // Fallback: Deserialize from raw JSON
                try {
                    stripeObject = deserializer.deserializeUnsafe();
                    if (stripeObject == null) {
                        log.warn("Failed to deserialize webhook object for event: {}", event.getType());
                        return ResponseEntity.ok().build();
                    }
                } catch(Exception e) {
                    log.warn("Unsafe deserialization failed for event {}: {}", event.getType(), e.getMessage());
                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Deserialization failed");
                }
            }

            // Now extract metadata only if it's a Checkout Session
            Map<String, String> metadata = new HashMap<>();
            if(stripeObject instanceof Session session){
                metadata = session.getMetadata();
            }

            // Pass to your processor
            paymentProcessor.handleWebhookEvent(event.getType(), stripeObject, metadata);
            return  ResponseEntity.ok().build();

        } catch (Exception e) {
            throw new RuntimeException("Webhook error: " + e.getMessage());
        }
    }


}
